arschmitz commented would you be comfortable with continuing to allow $(window).offset() to throw , but returning zeros for disconnected elements ? yes this would be what i would recommend the window change should be rare and is very very simple to fix , so as long as its handled by migrate i see no issue . the issues with offset on hidden elements specifically seems like a much bigger problem and honestly will make offset a pita to use . how often do you simultaneously set the offset of more than one element ? im not aware of any case in either library where this is done ( i can only think of one case where i did this ever ) it was just the first thing i thought of looking at the code because the offset documentation says "set the current coordinates of every element in the set of matched elements , relative to the document ." specifically mentioning collections being supported . the behavior would actually be more in line with native gbcr this seems like a valid point to me .

timmywil commented for the first case , i think undefined is more accurate . retrieving offset on a disconnected element doesn 't make much sense when you think about it . for the second , i 'd be in support of failing silently and returning undefined .

arschmitz commented also you return undefined on disconnected or hidden nodes why would you throw on window but return undefined in those cases returning undefined in any "invalid" case would seem better .

timmywil commented behavior for invalid input is undefined . since getting offset on a window is not defined behavior , it may throw an error or it may not . we 're going to let migrate take over on this one . if it turns out that this causes too much of an uproar in user code , we can address that after beta release .

gibson042 commented are the failures all from stuff like $( element || window ).offset()? because if so , just use $( element ).offset() instead the method will return undefined if its context collection is empty . as part of the larger story , though , these are the kinds of things that i expect to see : failures from mild api misuse that are easy for consumers to fix . if we 're not serious about valid vs . invalid input for our code , then i want to know now , because we 'll just end up backing out every other change .

gabrielschulhof commented @arschmitz @timmywil i 'll test my pr flat -out against mobile .

timmywil commented @gibson042 i 'd just like to point out that i do not disagree with you on how invalid input should be handled . the problem is figuring out how much we can change right now without causing too much of a ruckus . so , i wouldn 't interpret any change here as a policy change to be applied throughout the codebase . @arschmitz is this the only breaking change you 've noticed so far in regards to how well previous versions of ui work with jquery 3 .0?

arschmitz commented @timmywil so most of this issue discussion has been about the change to $( window ).offset() because i thought the changes in the first part of my opening comment about returning undefined on hidden or detached elements was in tests only . however i was wrong and i think this has more potential to break things in userland then the change for how window is handled . this comes up in ui and mobile quite a bit it turns out . both jquery ui and mobile allow widgets to be instantiated on a default element in a detached state via $. ui [widgetname]() and also just in general allow instantiating widgets on detached elements for improved performance among other reasons . there are also many many situations where a widget or other plugin of some sort may be instantiated or called inside of a hidden container . this is a major issue for plugin authors that cant ever reasonably know if they may be inside a hidden container ( think popups panels etc ) or in jquery mobile everything is hidden when the page is initialized . this all means where as in the past you could call offset () on any element with out any worry you now need to always check the return value before using it . so it will make a lot of code go from var left = $( elem ).offset().left to var offset = $( elem ).offset(); var left = offset ? offset .left || 0 ; who knows it would not surprise me if you start seeing things where offset is used a lot , doing something like the below to just not have to worry about it . $. fn .safeoffset = function () { return this .offset() || { top : 0 , left : 0 }; }; because with this change it essentially makes it ( as a plugin author ) never safe to use offset with out first checking its return value , unless it is in direct response to a user action , that essentially cant happen on hidden or detached elements . for example dragging and mouse interaction type stuff ( this is a case for many of the cases of offset in ui )

scottgonzalez commented are the failures all from stuff like $( element || window ).offset()? because if so , just use $( element ).offset() instead the method will return undefined if its context collection is empty . the code @arschmitz showed was simplified . in reality , what happens is we are determining which element to operate on , and the default element is the window . later on , we get the offset of the element , and that 's where we 're getting the error . we already have guards against windows in other parts of the code , so adding another one is fine .

gabrielschulhof commented @arschmitz @timmywil actually , with my fix , 7 more assertions fail :)

