scottywakefield commented @evangalen - that has done the job for me . i want to show invalid phone numbers so that they can be fixed , whilst still enforcing client side validation .

lastnico commented i do agree with @pkozlowski-opensource (at #1412 (comment)), i would expect such behavior too . how the user could fix a mistake from the model in the form (like a field not matching its pattern ) if he cannot even see what was the previous invalid (non-matching) value (think particularly about patterns added afterwards , while there are already existing data ). and after all , the values should be copied at least once at initialization time from model to input , because , once in inputs , they are going to be checked and will be copied back to model only once they will match the requirement (here: match their related ng -pattern).

ilovett commented i found the modelvalue being set to undefined after $setvalidity('x', false ) to be quite annoying and unexpected

mforce commented hi guys any updates on this , this issue is kind of driving me nuts ? i have another simple use case that is affected by this . let 's say one wants a simple way to display the character count of a textbox bound to a model field , if i want to use {{model.length}} the length property doesn 't work since the model is invalid and doesn 't have a value . is there a way to make this feature of the model optional ?

evangalen commented @narretz my workaround (for this particular issue ) enhances the formatting of all elements . in angularjs it 's allowed (and valid ) to create multiple directives on the same element (or attribute ). to fix this particular issue i register an additional 'input' directive that prepends (using "unshift") another format function the ndmodelcontroller #$formatters array . and since the $formatters array will be iterated from back to forward , the prepended function can intervene to return a string typed $modelvalue instead of undefined . however , my workaround is not a perfect solution in all cases . for instance what if you would have a date picker directive that uses an iso date notation as its $modelvalue. and what if this directive is configured to disallow dates in the past . in that case an invalid $modelvalue of '2001-12-31' (due to being a date in the past ) would lead to '2001-12-31' being shown (using the fix ) instead of a more more descriptive localized date representation (i.e. 31 -dec-2001). instead to best solution for this particular issue is to : modify the angularjs code base to no longer (exactly) use the same function in the $parsers as well as $formatters array ; instead of returning undefined in case of an invalid value , a formatter should still try to return a sensible representation . for instance if case of an iso date '2001-12-31' (being invalid , since it lies in the past ) the formatter could still return '31-dec-2001', however in case of a really incorrect date like 'abcd-12-31' it would probably be best to just return undefined . finally the documentation could be modified to describe in more detail how a formatter function should be correctly implemented .

pkozlowski -opensource commented hi ! there was a discussion about this on the mailing list : https ://groups.google.com/d/topic/angular/8fk-ya6juzo/discussion it is kind of corner case but i do agree that this is not intuitive . i would expect the data to be displayed and the input / form marked as invalid .

digitalicarus commented another option is to keep a separate copy of what you want to retain in the input and set that as the value . you can use whichever one you choose in your submit handler . this works well for me and i get the unaltered copy and the validated copy in scope , as well as all the interesting classes on the element from validation . <!-- ng -model gets filtered /erased by validation , so we keep a copy of the unvalidated input --> <input maxlength ="50" ng -maxlength="50" ng -minlength="{{searchsubject.minlength || 2 }}" ng -pattern="searchsubject.pattern" ng -model="searchvalue" placeholder ="{{searchsubject.placeholder}}" value ="{{searchvalueunvalidated}}" ng -keyup="searchvalueunvalidated = $event.target.value" ng -required />

petebacondarwin commented having played around with angular forms for some time now , i am not convinced that the model that is bound to the input controls should "really" be the truth . there are use cases where you have inputs that are not entirely valid but are good enough to be kept . a simple example would be writing an email . imagine i am writing an email to some one . i write down their email address but it is not quite correct - in fact it is not a valid email address at all . i decide to save a draft copy and come back to the address issue later . right now , an angularjs form would not allow us to save the "incorrect" email address in the draft email since the email is not valid . i believe that what we ought to do is decouple "$parsers and $formatters" from "$validators". the idea being that the former can make changes to the values as they pass between the model and the view , while the latter can set whether we consider the value valid or not . the model will still be updated even if the view is invalid but the ngmodelcontroller will know it is not valid . we also have to do this anyway if our validator is asynchronous , since we have to return "some" value while we wait for the asynchronous validation to occur . one thing that we are doing in our apps any way , is to store a copy of the "original" model so that we can "reset" the form . this is a very nice pattern and allows us to also do neat things , like disable the save button if what is in the form is no different to what was there originally - this is subtly different to being $pristine, since the user could change something and then back again with the form no longer $pristine. @mhevery what do you think ?

narretz commented yep , it 's all good now ! 9314719 restored the behvaior of not setting the model to undefined when you set the validity with $setvalidity, so this is also resolved . i 'm not a big fan of this , but hey .

jlmakes commented i was creating a character counter (eg. ng -bind="50 - ngmodel .length"), with ng -maxlength="50" on the related input however , the character counter displays nothing after it exceeds 50 characters , instead of a negative value . has anyone found a way around this behavior ? i 'm using angular 1 .2.0-rc.2.

